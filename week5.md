---
description: 5주차 강의
---

# 1. Dependency Injection
### Spring AOP(Aspect Oriented Programming)
 AOP는 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍으로 불린다.<br>
 관점 지향은 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것. 모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말함.<br>
AOP에서 각 관점을 기준으로 로직을 모듈화한다는 것은 코드들을 부분적으로 나누어서 모듈화하겠다는 의미이며, 소스 코드 상에서 다른 부분에 계속 반복해서 쓰이는 코드(흩어진 관심사_Crosscutting Concerns)를 Aspect로 모듈화하고 핵심적인 비즈니스 로직에서 분리하여 재사용하겠다는 것이 AOP의 취지이다.
- AOP의 주요 개념
  - Aspect: 흩어진 관심사를 모듈화 한 것. 주로 부가 기능을 모듈화 함.
  - Target: 클래스나 메서드 등 Aspect를 적용하는 곳
  - Advice: 실질적으로 해야할 일에 대한 것. 실질적 부가기능을 담은 구현체
  - JointPoint: Advice가 적용될 위치, 끼어들 수 있는 지점. 메서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내 올 때 등 다양한 시점에 적용 가능
  - PointCut: JointPoint의 상세한 스펙을 정의ㅣ한 것으로 구체적으로 Advice가 실행될 지점을 정할 수 있음.

- Spring AOP 특징
  - 프록시 패턴 기반의 AOP 구현체, 접근 제어 및 부가기능을 추가하기 위해 프록시 객체를 사용함.
  - Spring bean에만 AOP를 적용 가능
  - 모든 AOP 기능을 제공하는 것이 아닌 Spring IoC와 연동하여 엔터프라이즈 애플리케이션에서 흔한 문제(중복코드, 프록시 클래스 작성의 번거로움, 객체들 간 관계 복잡도 증가 등)에 대한 해결책을 지원하는 것이 목적

### Dependency Injection
의존성 주입.<br>
한 객체가 어떤 객체(구체 클래스)에 의존할 것인지는 별도의 관심사. Spring은 의존성 주입을 도와주는 DI컨테이너로서, 강하게 결합된 클래스들을 분리하고, 애플리케이션 실행 시점에 객체 간의 관계를 결정해 줌으로써 결합도를 낮추고 유연성을 확보해준다. 이러한 방법은 상속보다 훨씬 유연하다. 단, 한 객체가 다른 객체를 주입받으려면 반드시 DI 컨테이너에 의해 관리되어야 한다.

### 싱글턴 패턴
싱클턴은 오직 하나의 객체만을 생성할 수 있는 클래스를 말하며, 싱글턴 패턴을 사용하면 쉽게 객체의 유일성을 보장할 수 있다.<br>

### IoC(Inversion of Control)
전통적인 3계층
1. Presentation
2. Domain
3. Data

DDD의 4계층
1. UI Layer
2. Application Layer
3. Domain Layer
4. Infrastructure Layer

### Spring Bean
응집도는 컴퓨터 프로그래밍에서 모듈 안의 요소들이 함께 속하는 정도를 가리키며, 메소드와 클래스의 데이터간 관계의 강도를 의미한다. 결합도와 대비된다.

### BeanFactory
응집도는 컴퓨터 프로그래밍에서 모듈 안의 요소들이 함께 속하는 정도를 가리키며, 메소드와 클래스의 데이터간 관계의 강도를 의미한다. 결합도와 대비된다.
<br>

# 2. Unit Test
### V 모델
  데이터의 CRUD 처리를 담당하는 객체 혹은 패턴을 의미.<br>
  업무와 DBMS를 분리하기 위해 사용하며, 변경 부분을 캡슐화 시켜 최소화한다.

### Test Matrix
 다수의 데이터를 그루핑해서 효율적으로 과리할 수 있는 데이터 스트럭쳐이며, 배열과 달리 인덱스가 없으며, 이로 인해 빈틈없는 데이터의 적재가 가능함.

### 내적 품질(테스트 코드 작성 등)을 높이면 좋은 이유
Key, Value가 존재한다. Key는 중복을 허용하지 않는 ID값이며, Value는 중복을 허용하는 데이터 값이다. 기본적으로 순서가 없다. Key의 검색 속도가 속도를 좌우한다.

## JUnit
Key, Value가 존재한다. Key는 중복을 허용하지 않는 ID값이며, Value는 중복을 허용하는 데이터 값이다. 기본적으로 순서가 없다. Key의 검색 속도가 속도를 좌우한다.

## 단위 테스트
Key, Value가 존재한다. Key는 중복을 허용하지 않는 ID값이며, Value는 중복을 허용하는 데이터 값이다. 기본적으로 순서가 없다. Key의 검색 속도가 속도를 좌우한다.

## E2E 테스트
Key, Value가 존재한다. Key는 중복을 허용하지 않는 ID값이며, Value는 중복을 허용하는 데이터 값이다. 기본적으로 순서가 없다. Key의 검색 속도가 속도를 좌우한다.
<br>

# 3. Spring Test
### 통합 테스트(Integration Test)
  개발 대상과 범위를 간단히 도메인이라고 봤을 때, 도메인 모델이란 도메인을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화 시킨 것.

### @Autowired
 실제로 DB에 접근하는 객체이며, Service와 DB를 연결하는 고리의 역할을 함.
 <br>SQL을 사용하여 DB에 접근한 후 적절한 CRUD API를 제공한다.

### @SpyBean
도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.<br>
속성값 자체가 식별값이므로 값이 바뀌면 다른 값이 되어 추적이 불가하고, 복사될 때 의도치않은 객체들이 함께 변경되는 문제를 유발하므로 VO는 반드시 값을 변경할 수 없는 불변 객체로 만들어야 한다. 즉, 값을 변경할 수 있는 수정자(setter)가 없어야 한다.<br>
VO를 통해 도메인을 설계한다면, 객체가 생성될 때 해당 객체 안에 제약 사항을 추가할 수 있고, Entity의 원시 값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있어서, 테이블 관점이 아닌 객체 지향적인 관점으로 프로그래밍할 수 있다.

### MockMvc
도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.<br>
속성값 자체가 식별값이므로 값이 바뀌면 다른 값이 되어 추적이 불가하고, 복사될 때 의도치않은 객체들이 함께 변경되는 문제를 유발하므로 VO는 반드시 값을 변경할 수 없는 불변 객체로 만들어야 한다. 즉, 값을 변경할 수 있는 수정자(setter)가 없어야 한다.<br>
VO를 통해 도메인을 설계한다면, 객체가 생성될 때 해당 객체 안에 제약 사항을 추가할 수 있고, Entity의 원시 값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있어서, 테이블 관점이 아닌 객체 지향적인 관점으로 프로그래밍할 수 있다.

### @SpyBean
도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.<br>
속성값 자체가 식별값이므로 값이 바뀌면 다른 값이 되어 추적이 불가하고, 복사될 때 의도치않은 객체들이 함께 변경되는 문제를 유발하므로 VO는 반드시 값을 변경할 수 없는 불변 객체로 만들어야 한다. 즉, 값을 변경할 수 있는 수정자(setter)가 없어야 한다.<br>
VO를 통해 도메인을 설계한다면, 객체가 생성될 때 해당 객체 안에 제약 사항을 추가할 수 있고, Entity의 원시 값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있어서, 테이블 관점이 아닌 객체 지향적인 관점으로 프로그래밍할 수 있다.

### MockBean
도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.<br>
속성값 자체가 식별값이므로 값이 바뀌면 다른 값이 되어 추적이 불가하고, 복사될 때 의도치않은 객체들이 함께 변경되는 문제를 유발하므로 VO는 반드시 값을 변경할 수 없는 불변 객체로 만들어야 한다. 즉, 값을 변경할 수 있는 수정자(setter)가 없어야 한다.<br>
VO를 통해 도메인을 설계한다면, 객체가 생성될 때 해당 객체 안에 제약 사항을 추가할 수 있고, Entity의 원시 값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있어서, 테이블 관점이 아닌 객체 지향적인 관점으로 프로그래밍할 수 있다.

### @WebMvcTest
도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.<br>
속성값 자체가 식별값이므로 값이 바뀌면 다른 값이 되어 추적이 불가하고, 복사될 때 의도치않은 객체들이 함께 변경되는 문제를 유발하므로 VO는 반드시 값을 변경할 수 없는 불변 객체로 만들어야 한다. 즉, 값을 변경할 수 있는 수정자(setter)가 없어야 한다.<br>
VO를 통해 도메인을 설계한다면, 객체가 생성될 때 해당 객체 안에 제약 사항을 추가할 수 있고, Entity의 원시 값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있어서, 테이블 관점이 아닌 객체 지향적인 관점으로 프로그래밍할 수 있다.

